# 数据结构

- 数组部分和哈希部分

  Lua table 实际上是由两部分组成，一部分用于存储数组元素，另一部分用于存储键值对形式的哈希元素。当使用整数作为索引且索引是连续的从 1 开始的正整数时，元素会被存储在数组部分；而当使用其他类型的值作为键时，元素会被存储在哈希部分。这种混合的数据结构使得 table 能够同时高效地处理两种不同类型的存储需求。

- 结点结构

  在内部，table 的每个元素（无论是数组部分还是哈希部分）都被存储为一个节点。每个节点包含了键、值以及指向下一个节点的指针等信息。这种链式结构使得 table 可以方便地进行元素的插入、删除和查找操作。

# 内存管理

- 动态增长

  Lua table 会根据需要动态地分配内存来存储新的元素。当向 table 中添加元素时，如果当前的内存空间不足以容纳新元素，Lua 会自动分配更大的内存块，并将原有的元素复制到新的内存空间中，以保证 table 能够容纳更多的元素。

- 内存回收

  当 table 中的某些元素被删除或不再被引用时，Lua 的垃圾回收机制会自动回收这些元素所占用的内存空间。这样可以有效地避免内存泄漏问题，保证程序的内存使用效率。

# 哈希算法

- 键的哈希计算

  对于存储在哈希部分的元素，Lua 会使用哈希算法对键进行计算，得到一个哈希值。这个哈希值用于确定元素在哈希表中的存储位置。通过合理的哈希算法，可以尽量减少哈希冲突的发生，提高元素查找的效率。

- 冲突解决

  尽管哈希算法会尽量避免冲突，但在实际情况中，仍然可能会出现不同的键计算得到相同哈希值的情况，即哈希冲突。Lua 采用了链式地址法来解决哈希冲突，即将具有相同哈希值的元素存储在一个链表中，当查找元素时，需要遍历这个链表来找到对应的键值对。

# 操作实现

- 插入操作

  当向 table 中插入一个新元素时，Lua 首先会根据键的类型判断该元素应该存储在数组部分还是哈希部分。如果是数组部分，且索引连续，会直接将元素存储在对应的位置；如果索引不连续或属于哈希部分，则会通过哈希算法计算出存储位置，并将新元素插入到相应的链表中。

- 查找操作

  对于查找操作，Lua 同样会先根据键的类型判断元素可能存储的位置。如果是数组部分，会直接根据索引进行查找；如果是哈希部分，则通过哈希值找到对应的链表，然后在链表中逐个比较键来查找目标元素。

- 删除操作

  删除操作会根据键找到对应的元素，并将其从 table 中移除。对于哈希部分的元素，还需要调整链表的指针，以保持链表的完整性。同时，Lua 的垃圾回收机制会在适当的时候回收被删除元素所占用的内存空间。

# 性能优化

- 缓存哈希值

  为了提高哈希部分元素查找的效率，Lua 会在第一次计算键的哈希值后将其缓存起来，下次查找时直接使用缓存的哈希值，避免了重复计算哈希的开销。

- 数组部分的优化

  对于数组部分，Lua 利用了 CPU 对连续内存访问的优化特性，当按顺序访问数组元素时，可以获得较好的性能。同时，在一些操作中，如 table 的遍历，会优先处理数组部分，以提高遍历的效率。
